program main
  USE mod_parameters
  USE mod_VERIF
  USE mod_VOI
  USE mod_CONNEC_COO
  Implicit None
  logical  :: test
  Real(PR),dimension(2) :: TXY
  Real(PR) :: WIZ
  PRINT*,'DEFINE:', STCO,STCN,NBPELE,NBPEDG
  CALL RD_MF_CONNEC_COO(MESH_FILE,DIM,NV,NE,NT,T1CO,T1CN,T1ED,T1ED_L,T2D)

  CALL QK_INFO_CNCO(T1CN, T1CO, MESH_QK_CNCO)
  CALL BUILD_HEAD_VOI_CN(T1CN,head,voi)
  FCRTL = WR_verif_CNCO(MESH_QK_CNCO)
  DEALLOCATE(head, voi)

  CALL QK_INFO_T2DCO(T2D, T1CO, MESH_QK_T2DCO)
  CALL  BUILD_HEAD_VOI_T2D(T2D,head,voi)
  FCRTL = WR_verif_T2DCO(MESH_QK_T2DCO)
  DEALLOCATE(head, voi)
  TXY(1) = 0.25; TXY(2) = 0.25
  WIZ =0.000001_PR
  in_c_inscr(TXY,CO3P,WIZ)
  DEALLOCATE(T2D, T1CO, T1CN, T1ED, T1ED_L)

CONTAINS

  logical function in_c_inscr(target,CO3P,WIZ)
    implicit none
    Real(PR), Dimension(2), Intent(IN) :: target !X Y
    Real(PR), Dimension(6), Intent(IN) :: CO3P   !X1 Y1 X2 Y2 X3 Y3
    Real(PR), Intent(IN) :: WIZ ! What IS ZERO i.e la tol pour Dist
    Real(PR), Dimension(4) :: mid, med!Point Milieu au segment, M�diatrice du segment
    Real(PR) :: P12X, P12Y, P23X, P23Y, P31X, P31Y
    Real(PR) :: Xc, Yc !CENTRE DU CERCLE CIRCONSCRIT
    Real(PR) :: Rayon, Dist

    Real(PR) :: a, aa, b, bb !a, aa:pente mediatrice et b, bb ordonnées à l'origine

    Integer  :: S1, S2, S3, S4
    Integer  :: k1, k2, k3, k4, k5, k6, k7, k8
    Integer  :: S5, S6


    !Calcul des composantes vectorielles du vecteur PiPj, (i,j=1,3):
    P12X = CO3P(3)-CO3P(1); P12Y = CO3P(4)-CO3P(2)
    P23X = CO3P(5)-CO3P(3); P23Y = CO3P(6)-CO3P(4)
    P31X = CO3P(1)-CO3P(5); P31Y = CO3P(2)-CO3P(6)
    !TEST POUR SAVOIR SI UN COTE EST PARALLELE A L'AXE Ox ET DONC EVITEE UNE DIVISION PAR 0:
    S5 = 0; S6 = 0
    IF(P12Y == 0.0_PR)THEN!P12 COLINEAIRE A L'AXE Ox
       ! DONC UTILISER P23 ET P31
       S1 = 2; k2 = 2*S1; k1 = k2-1
       S2 = 3; k4 = 2*S2; k3 = k4-1
       S3 = 3; k6 = 2*S3; k5 = k6-1
       S4 = 1; k8 = 2*S4; k7 = k8-1
       S5 = 10; S6 = 1
       !!$mid(1) = (CO3P(3) + CO3P(5))/2.0_PR; mid(2) = (CO3P(4) + CO3P(6))/2.0_PR !mid [P2P3].x, mid [P2P3].y
       !!$mid(3) = (CO3P(1) + CO3P(5))/2.0_PR; mid(4) = (CO3P(2) + CO3P(6))/2.0_PR !mid [P1P3].x, mid [P1P3].y
    ELSE IF(P23Y == 0.0_PR)THEN!P23 COLINEAIRE A L'AXE Ox
       ! DONC UTILISER P12 ET P31
       S1 = 1; k2 = 2*S1; k1 = k2-1
       S2 = 2; k4 = 2*S2; k3 = k4-1
       S3 = 3; k6 = 2*S3; k5 = k6-1
       S4 = 1; k8 = 2*S4; k7 = k8-1
       S5 = 10; S6 = 2
       !!$mid(1) = (CO3P(1) + CO3P(3))/2.0_PR; mid(2) = (CO3P(2) + CO3P(4))/2.0_PR !mid [P1P2].x, mid [P1P2].y
       !!$mid(3) = (CO3P(1) + CO3P(5))/2.0_PR; mid(4) = (CO3P(2) + CO3P(6))/2.0_PR !mid [P1P3].x, mid [P1P3].y
    ELSE IF(P31Y == 0.0_PR)THEN!P31 COLINEAIRE A L'AXE Ox
       ! DONC UTILISER P12 ET P23
       S1 = 1; k2 = 2*S1; k1 = k2-1
       S2 = 2; k4 = 2*S2; k3 = k4-1
       S3 = 2; k6 = 2*S3; k5 = k6-1
       S4 = 3; k8 = 2*S4; k7 = k8-1
       S5 = 10; S6 = 3
       !!$mid(1) = (CO3P(1) + CO3P(3))/2.0_PR; mid(2) = (CO3P(2) + CO3P(4))/2.0_PR !mid [P1P2].x, mid [P1P2].y
       !!$mid(3) = (CO3P(3) + CO3P(5))/2.0_PR; mid(4) = (CO3P(4) + CO3P(6))/2.0_PR !mid [P2P3].x, mid [P2P3].y
    END IF

    !Test Pour savoir si un second côtés est parallèle Oy:
    IF(P12X == 0.0_PR .OR. P23Y == 0.0_PR .OR. P31Y == 0.0_PR)THEN
      if(S5 == 10)then
         !TEST POUR SAVOIR SI UN COTE EST PARALLELE A L'AXE Oy:
         IF(P12X == 0.0_PR)THEN!P12 COLINEAIRE A L'AXE Oy
            ! DONC UTILISER P31 OU P23 POUR Xc (mean abscisses non egales des pts)
            Xc = (CO3P(1)+CO3P(5))*0.5_PR
            !Pour Yc comme on ne traite ques des points distincts,
            !Le vecteur PiPj est forcement non nul donc on peut
            !Directement prendre P12Y
            Yc = (CO3P(2)+CO3P(4))*0.5_PR !or (CO3P(2)+CO3P(6))*0.5_PR
            !SI hit :
            S5 = 15
         ELSE IF(P23Y == 0.0_PR)THEN!P23 COLINEAIRE A L'AXE Oy
            ! DONC UTILISER P12 OU P31 POUR Xc
            Xc = (CO3P(1)+CO3P(3))*0.5_PR
            !Pour Yc comme on ne traite ques des points distincts,
            !Le vecteur PiPj est forcement non nul donc on peut
            !Directement prendre P23Y
            Yc = (CO3P(4)+CO3P(6))*0.5_PR !or (CO3P(2)+CO3P(4))*0.5_PR
            !SI hit :
            S5 = 15
         ELSE IF(P31Y == 0.0_PR)THEN!P31 COLINEAIRE A L'AXE Oy
            ! DONC UTILISER P12 OU P23 POUR Xc
            Xc = (CO3P(1)+CO3P(3))*0.5_PR
            !Pour Yc comme on ne traite ques des points distincts,
            !Le vecteur PiPj est forcement non nul donc on peut
            !Directement prendre P31Y
            Yc = (CO3P(6)+CO3P(2))*0.5_PR !or (CO3P(2)+CO3P(4))*0.5_PR
            !SI hit :
            S5 = 15
         END IF
      end if
  END IF
    !ET DONC DANS LE CAS S5 == 10:
  IF(S5 == 10)THEN
    SELECT CASE(S6)
    CASE(1)
      mid(1) = (CO3P(k1) + CO3P(k3))/2.0_PR; mid(2) = (CO3P(k2) + CO3P(k4))/2.0_PR !mid [P2P3].x, mid [P2P3].y
      mid(3) = (CO3P(k7) + CO3P(k5))/2.0_PR; mid(4) = (CO3P(k8) + CO3P(k6))/2.0_PR !mid [P1P3].x, mid [P1P3].y
    CASE(2)
      mid(1) = (CO3P(k1) + CO3P(k3))/2.0_PR; mid(2) = (CO3P(k2) + CO3P(k4))/2.0_PR !mid [P1P2].x, mid [P1P2].y
      mid(3) = (CO3P(k7) + CO3P(k5))/2.0_PR; mid(4) = (CO3P(k8) + CO3P(k6))/2.0_PR !mid [P1P3].x, mid [P1P3].y
    CASE(3)
      mid(1) = (CO3P(k1) + CO3P(k3))/2.0_PR; mid(2) = (CO3P(k2) + CO3P(k4))/2.0_PR !mid [P1P2].x, mid [P1P2].y
      mid(3) = (CO3P(k7) + CO3P(k5))/2.0_PR; mid(4) = (CO3P(k8) + CO3P(k6))/2.0_PR !mid [P2P3].x, mid [P2P3].y
    END SELECT
  ELSE IF(S5 == 0)THEN !peut importe dans celui-ci
    mid(1) = (CO3P(1) + CO3P(3))/2.0_PR; mid(2) = (CO3P(2) + CO3P(4))/2.0_PR !mid [P1P2].x, mid [P1P2].y
    mid(3) = (CO3P(3) + CO3P(5))/2.0_PR; mid(4) = (CO3P(4) + CO3P(6))/2.0_PR !mid [P2P3].x, mid [P2P3].y
  END IF

  IF(S5/=15)THEN
    a = -(CO3P(k3)-CO3P(k1))/(CO3P(k4)-CO3P(k2))
    b = (CO3P(k3)*CO3P(k3)-CO3P(k1)*CO3P(k1)+CO3P(k4)*CO3P(k4)-CO3P(k2)*CO3P(k2))*0.50_PR
    b = b/(CO3P(k4)-CO3P(k2))

    aa = -(CO3P(k7)-CO3P(k5))/(CO3P(k8)-CO3P(k6))
    bb = (CO3P(k7)*CO3P(k7)-CO3P(k5)*CO3P(k5)+CO3P(k8)*CO3P(k8)-CO3P(k6)*CO3P(k6))*0.50_PR
    bb = bb/(CO3P(k8)-CO3P(k6))

    Xc = (bb-b)/(a-aa); Yc = -a * Xc + b
  END IF

  Rayon = SQRT( (CO3P(k1)-Xc)**2 + (CO3P(k2)-Yc)**2 )
  Dist  = SQRT( (target(1)-Xc)**2 + (target(2)-Yc)**2 )
  IF(ABS(Dist-Rayon)<WIZ)THEN
    in_c_inscr = .TRUE.
  ELSE
    in_c_inscr = .FALSE.
  END IF

  OPEN(10,file='in_c_inscr.txt',position='append')
  WRITE(10,*)CO3P(:),Xc,Yc
  CLOSE(10)
  !Calcul des point milieux:
  !!$mid(1) = (CO3P(1) + CO3P(3))/2.0_PR; mid(2) = (CO3P(2) + CO3P(4))/2.0_PR !mid [P1P2].x, mid [P1P2].y
  !!$mid(3) = (CO3P(3) + CO3P(5))/2.0_PR; mid(4) = (CO3P(4) + CO3P(6))/2.0_PR !mid [P2P3].x, mid [P2P3].y
  !!$mid(5) = (CO3P(1) + CO3P(5))/2.0_PR; mid(6) = (CO3P(2) + CO3P(6))/2.0_PR !mid [P1P3].x, mid [P1P3].y
  end function in_c_inscr
end program main
